/////////////////////////////////////////////////////////////////////
// @(#)Route.java
//
// @author BJ Premore (SSFNet)
// @author Bruno Quoitin (bqu@infonet.fundp.ac.be)
// @lastdate 09/08/2002
/////////////////////////////////////////////////////////////////////

package infonet.javasim.bgp4;

import infonet.javasim.bgp4.path.ASpath;
import infonet.javasim.bgp4.path.Aggregator;
import infonet.javasim.bgp4.path.AtomicAggregate;
import infonet.javasim.bgp4.path.Attribute;
import infonet.javasim.bgp4.path.ClusterList;
import infonet.javasim.bgp4.path.Community;
import infonet.javasim.bgp4.path.ExtendedCommunities;
import infonet.javasim.bgp4.path.ExtendedCommunity;
import infonet.javasim.bgp4.path.LocalPref;
import infonet.javasim.bgp4.path.MED;
import infonet.javasim.bgp4.path.NextHop;
import infonet.javasim.bgp4.path.Origin;
import infonet.javasim.bgp4.path.OriginatorID;
import infonet.javasim.bgp4.path.Segment;
import infonet.javasim.bgp4.path.TBID;
import infonet.javasim.util.IPaddress;

import java.util.ArrayList;

import tid.utils.BytesUtils;


// ===== class infonet.javasim.bgp4.Route ======================== //
/**
 * Information describing a single route.  A route is described as a
 * unit of information that pairs a destination with the attibutes of
 * a path to that destination. In other words, route = destination +
 * path attributes.
 */
public class Route {

    // ......................... constants ....................... //

    /** For undefined string values. */
    public static final String undefined = "undefined";
     
    /** The DML string names of route attributes other than path
     * attributes. */ 
    public static final String[] attrib_names = { undefined, "nlri" };

    /** The maximum route attribute type code for non- path attributes. */
    public static final int MAX_TYPECODE = -1;

    /** The minimum route attribute type code for non- path attributes. */
    public static final int MIN_TYPECODE = -1;

    /** A route attribute "type code" value for NLRI.  It is negative
     * since the type codes for path attributes are all positive. */
    public static final int NLRI_TYPECODE = -1;


    // ........................ member data ...................... //

    /** The destination of the route.  This is actually just an IP
     *  address prefix, so it may represent a specific host, subnet,
     *  AS, or perhaps an even larger (possibly geographical) portion
     *  of the network. */
    //bqu: public IPaddress nlri;
    public IPaddress nlri;
  
    /** An array of path attributes which describe the path to the
     *  destination. This information is received via update
     *  messages. */
    public Attribute[] pas;

    /** Variables used to control the information that appears in the
     * string generated by Route.toString().
     */
    public static boolean to_string_comm   = true/*false*/;
    public static boolean to_string_extcomm= true/*false*/;


    // ----- constructor Route() --------------------------------- //
    /**
     * Default initializer.
     */
    public Route() {
	// We initialize the array so that we can index it by
	// attribute type code. It's easier than having an unordered
	// array and having to search through it each and every time
	// when looking for a particular attribute.  This way is less
	// space-efficient, but more time-efficient.
	pas = new Attribute[Attribute.MAX_TYPECODE+1];
	for (int i = 0;i<Attribute.MAX_TYPECODE+1;i++)
		pas[i] = null;
	// All mandatory attributes should be set immediately after a
	// route is constructed.  Here we initialize the AS path only,
	// because an empty AS path can be valid for routes originated
	// by the local BGP speaker.
	pas[ASpath.TYPECODE] = new ASpath(new ArrayList());

	set_tbid(-1);
    }

    // ----- constructor Route(Route) ---------------------------- //
    /**
     * Constructs a new route based on an existing one.
     *
     * @param rte  The existing route on which to base the new one.
     */
    public Route(Route rte) {
	nlri= new IPaddress(rte.nlri);
	pas = copy_attribs(rte.pas);
    }

    // ----- constructor Route(IPaddress,Attribute[]) ------------ //
    /**
     * Constructs a route given the destination and path attributes.
     *
     * @param ipa  The destination of the route.
     * @param pa   The path attributes associated with this route.
     */
    public Route(IPaddress ipa, Attribute[] pa) {
	nlri = ipa;
	pas  = pa;
    }

    // ----- Route.copy_attribs ---------------------------------- //
    /**
     * Copies the array of path attributes into a new array and returns it.
     *
     * @param attribs  An array of path attributes.
     * @return a copy of the array of path attributes
     */
    public static final Attribute[] copy_attribs(Attribute[] pas) {
	    if (pas == null) {
		    return null;
		}
		Attribute[] attribs = new Attribute[pas.length];
		for (int i=0; i<pas.length; i++) {
		    if (pas[i] != null) {
			attribs[i] = pas[i].copy();
		    }
		    else pas [i] = null;
		}
		return attribs;
    }

    // ----- Route.set_nlri -------------------------------------- //
    /**
     * Sets the value of the NLRI.
     *
     * @param ipa  The value to use for the NLRI.
     */
    public final void set_nlri(IPaddress ipa) {
	nlri = ipa;
    }

    // ----- Route.origin ---------------------------------------- //
    /**
     * Returns the value of the origin path attribute.
     *
     * @return the value of the origin path attribute
     */
    public final byte origin() {
	return ((Origin)pas[Origin.TYPECODE]).typ;
    }

    // ----- Route.set_origin ------------------------------------ //
    /**
     * Sets the value of the origin path attribute.  If the attribute
     * does not yet exist, it is created.
     *
     * @param t  An origin type code.
     */
    public final void set_origin(byte t) {
	if (pas[Origin.TYPECODE] != null) {
	    ((Origin)pas[Origin.TYPECODE]).typ = t;
	} else {
	    pas[Origin.TYPECODE] = new Origin(t);
	}
    }

    // ----- Route.aspath ---------------------------------------- //
    /**
     * Returns the AS path attribute.
     *
     * @return the AS path attribute
     */
    public final ASpath aspath() {
	return (ASpath)pas[ASpath.TYPECODE];
    }

    // ----- Route.prepend_as ------------------------------------ //
    /**
     * Prepends an AS NHI prefix address to the AS path attribute.
     * Creates the attribute if it does not yet exist.
     *
     * @param asnh  The AS NHI prefix address to prepend to the AS
     * path.
     */
    public final void prepend_as(int ASNum/*String asnh*/) {
	if (aspath() == null) {
	    pas[ASpath.TYPECODE] = new ASpath(new ArrayList());
	}
	aspath().prepend_as(ASNum/*asnh*/);
    }

    // ----- Route.nexthop --------------------------------------- //
    /**
     * Returns the value of the next hop path attribute.
     *
     * @return the value of the next hop path attribute
     */
    public final IPaddress nexthop() {
	if (pas[NextHop.TYPECODE] != null) {
	    return ((NextHop)pas[NextHop.TYPECODE]).ipaddr;
	} else {
	    return null;
	}
    }

    // ----- Route.set_nexthop ----------------------------------- //
    /**
     * Sets the next hop path attribute for this route.  Creates the
     * attribute if it does not already exist.
     *
     * @param nexthop  The value to which to set the next hop
     * attribute.
     */
    public final void set_nexthop(IPaddress nexthop) {
	if (pas[NextHop.TYPECODE] != null) {
	    ((NextHop)pas[NextHop.TYPECODE]).ipaddr = nexthop;
	} else {
	    pas[NextHop.TYPECODE] = new NextHop(nexthop);
	}
    }

    // ----- Route.has_med --------------------------------------- //
    /**
     * Returns whether or not the multiple exit discriminator path
     * attribute exists.
     *
     * @return true only if the MED path attribute exists
     */
    public final boolean has_med() {
	return (pas[MED.TYPECODE] != null);
    }

    // ----- Route.med ------------------------------------------- //
    /**
     * Returns the value of the multiple exit discriminator attribute.
     *
     * @return the multiple exit discriminator value
     */
    public final long med() {
	return ((MED)pas[MED.TYPECODE]).val;
    }

    // ----- Route.set_med --------------------------------------- //
    /**
     * Sets the value of the multiple exit discriminator path
     * attribute. The attribute is created if it does not yet exist.
     *
     * @param v  The value to use for the MED.
     */
    public final void set_med(int v) {
	if (has_med()) {
	    ((MED)pas[MED.TYPECODE]).val = v;
	} else {
	    pas[MED.TYPECODE] = new MED(v);
	}
    }

    // ----- Route.has_localpref --------------------------------- //
    /**
     * Returns whether or not the local preference path attribute
     * exists.
     *
     * @return true only if the local preference path attribute exists
     */
    public final boolean has_localpref() {
	return (pas[LocalPref.TYPECODE] != null);
    }

    // ----- Route.localpref ------------------------------------- //
    /**
     * Returns the value of the local preference attribute.
     *
     * @return the local preference of the route
     */
    public final long localpref() {
	return ((LocalPref)pas[LocalPref.TYPECODE]).val;
    }

    // ----- Route.set_localpref --------------------------------- //
    /**
     * Sets the value of the local preference path attribute.  The
     * attribute is created if it does not yet exist.
     *
     * @param pref  The value to use for the local preference
     * attribute.
     */
    public final void set_localpref(int pref) {
	if (has_localpref()) {
	    ((LocalPref)pas[LocalPref.TYPECODE]).val = pref;
	} else {
	    pas[LocalPref.TYPECODE] = new LocalPref(pref);
	}
    }

    // ----- Route.has_atomicagg --------------------------------- //
    /**
     * Returns whether or not the atomic aggregate attribute exists.
     *
     * @return true only if the atomic aggregate attribute exists
     */
    public final boolean has_atomicagg() {
	return (pas[AtomicAggregate.TYPECODE] != null);
    }

    // ----- Route.set_atomicagg --------------------------------- //
    /**
     * Adds the atomic aggregate path attribute to the route.
     */
    public final void set_atomicagg() {
	if (!has_atomicagg()) {
	    pas[AtomicAggregate.TYPECODE] = new AtomicAggregate();
	}
    }

    // ----- Route.has_aggregator -------------------------------- //
    /**
     * Returns whether or not the aggregator attribute exists.
     *
     * @return true only if the aggregator attribute exists
     */
    public final boolean has_aggregator() {
	return (pas[Aggregator.TYPECODE] != null);
    }

    // ----- Route.aggregator ------------------------------------ //
    /**
     * Returns the aggregator path attribute.
     *
     * @return the aggregator path attribute
     */
    public final Aggregator aggregator() {
	return (Aggregator)pas[Aggregator.TYPECODE];
    }

    // ----- Route.set_aggregator -------------------------------- //
    /**
     * Sets the value of the aggregator path attribute.  The attribute
     * is created if it does not yet exist.
     *
     * @param nh   The AS NHI address prefix of the aggregating BGP
     * speaker.
     * @param ipa  The IP address of the aggregating BGP speaker.
     */
    public final void set_aggregator(int ASNum, IPaddress ipa) {
	if (has_aggregator()) {
	    aggregator().ASNum= ASNum;
	    aggregator().ipaddr = ipa;
	} else {
	    pas[AtomicAggregate.TYPECODE] = new Aggregator(ASNum, ipa);
	}
    }

    // ----- Route.has_orig_id ----------------------------------- //
    /**
     * Returns whether or not the originator ID attribute exists.
     *
     * @return true only if the originator ID attribute exists
     */
    public final boolean has_orig_id() {
	return (pas[OriginatorID.TYPECODE] != null);
    }

    // ----- Route.orig_id --------------------------------------- //
    /**
     * Returns the value of the originator ID attribute.
     *
     * @return the originator ID of the route
     */
    public final IPaddress orig_id() {
	return ((OriginatorID)pas[OriginatorID.TYPECODE]).id;
    }

    // ----- Route.set_orig_id ----------------------------------- //
    /**
     * Sets the value of the originator ID path attribute.
     */
    public final void set_orig_id(IPaddress orig_id) {
	if (has_orig_id()) {
	    ((OriginatorID)pas[OriginatorID.TYPECODE]).id = orig_id;
	} else {
	    pas[OriginatorID.TYPECODE] = new OriginatorID(orig_id);
	}
    }

    // ----- Route.has_cluster_list ------------------------------ //
    /**
     * Returns whether or not the cluster list attribute exists.
     *
     * @return true only if the cluster list attribute exists
     */
    public final boolean has_cluster_list() {
	return (pas[ClusterList.TYPECODE] != null);
    }

    // ----- Route.cluster_list ---------------------------------- //
    /**
     * Returns the cluster list path attribute.
     *
     * @return the cluster list path attribute
     */
    public final ClusterList cluster_list() {
	return (ClusterList)pas[ClusterList.TYPECODE];
    }

    // ----- Route.append_cluster -------------------------------- //
    /**
     * Appends a cluster number to the cluster list attribute.  The
     * attribute is created if it does not yet exist.
     *
     * @param cnum  The cluster number to add to the cluster list.
     */
    public final void append_cluster(long cnum) {
	if (!has_cluster_list()) {
	    pas[ClusterList.TYPECODE] = new ClusterList(new ArrayList());
	}
	((ClusterList)pas[ClusterList.TYPECODE]).append(cnum);
    }

    // ----- Route.has_comm -------------------------------------- //
    public final boolean has_comm()
    {
	return pas[Community.TYPECODE] != null;
    }

    // ----- Route.comm ------------------------------------------ //
    public final Community comm()
    {
	return (Community) pas[Community.TYPECODE];
    }

    // ----- Route.append_comm ----------------------------------- //
    public final void append_comm(int comm)
    {
	if (!has_comm())
	    pas[Community.TYPECODE]= new Community();
	((Community) pas[Community.TYPECODE]).append(comm);
    }

    // ----- Route.strip_comm ------------------------------------ //
    public final void strip_comm()
    {
	pas[Community.TYPECODE]= null;
    }

    // ----- Route.has_extcomm ----------------------------------- //
    public final boolean has_extcomm()
    {
	return pas[ExtendedCommunities.TYPECODE] != null;
    }

    // ----- Route.extcomm --------------------------------------- //
    public final ExtendedCommunities extcomm()
    {
	return (ExtendedCommunities) pas[ExtendedCommunities.TYPECODE];
    }

    // ----- Route.append_extcomm -------------------------------- //
    public final void append_extcomm(ExtendedCommunity extcomm)
    {
	if (pas[ExtendedCommunities.TYPECODE] == null)
	    pas[ExtendedCommunities.TYPECODE]= new ExtendedCommunities();
	((ExtendedCommunities)
	 pas[ExtendedCommunities.TYPECODE]).append(extcomm);
    }

    // ----- Route.set_tbid -------------------------------------- //
    public final void set_tbid(int val)
    {
	TBID tbid;
	if (pas[TBID.TYPECODE] != null) {
	    tbid= (TBID) pas[TBID.TYPECODE];
	    tbid.val= val;
	} else
	    tbid= new TBID(val);
	pas[TBID.TYPECODE]= tbid;
    }

    // ----- Route.tbid ------------------------------------------ //
    public final int tbid()
    {
	return ((TBID) pas[TBID.TYPECODE]).val;
    }

    // ----- Route.remove_non_transitive_extcomm ----------------- //
    /**
     *
     */
    public final void remove_non_transitive_extcomm()
    {
	ExtendedCommunities tmp;

	if (pas[ExtendedCommunities.TYPECODE] != null) {
	    tmp= ((ExtendedCommunities) pas[ExtendedCommunities.TYPECODE]);
	    tmp.remove_non_transitive();
	    if (tmp.vals.size() == 0)
		pas[ExtendedCommunities.TYPECODE]= null;
	    else
		pas[ExtendedCommunities.TYPECODE]= tmp;
	}
    }

    // ----- Route.remove_attrib --------------------------------- //
    /**
     * Removes a path attribute from the route.
     *
     * @param typ  The type code of the path attribute to remove.
     */
    public final void remove_attrib(int typ) {
	pas[typ] = null;
    }

    // ----- Route.equals ---------------------------------------- //
    /**
     * Returns true only if the two routes have the same NLRI and path
     * attributes.
     *
     * @param rte  The route to compare with this one.
     * @return  true only if the two routes have the same NLRI and
     * path attributes
     */
    public final boolean equals(Object rte) {
	return (rte != null &&
		rte instanceof Route &&
		nlri.equals(((Route)rte).nlri) &&
		equal_attribs(((Route)rte).pas));
    }

    // ----- Route.equal_attribs --------------------------------- //
    /**
     * Returns true only if the two routes have equivalent path attributes.
     *
     * @param attribs  The path attributes to be compared.
     * @return true only if the two sets of path attributes are equivalent
     */
    public final boolean equal_attribs(Attribute[] attribs) {
	for (int i=1; i<pas.length; i++) {
	    if ((pas[i] == null && attribs[i] != null) || 
	    		(pas[i] != null && attribs[i] == null)) {

	    	return false;
	    }
	    if (pas[i] != null && !pas[i].equals(attribs[i])) {
	    	return false;
	    }
	}
	return true;
    }

    // ----- Route.incorporate_route ----------------------------- //
    /**
     * Incorporates the given route into this one (aggregates the two).
     *
     * @param r  The route to be aggregated into this one.
     */
    public final void incorporate_route(Route r) {

	// - - - - - aggregate the origins - - - - -
	if (origin() == Origin.INC || r.origin() == Origin.INC) {
	    // if either was INCOMPLETE, the aggregate must be INCOMPLETE
	    set_origin(Origin.INC);
	} else if (origin() == Origin.EGP || r.origin() == Origin.EGP) {
	    // else if either was EGP, the aggregate must be EGP
	    set_origin(Origin.EGP);
	} else { // in all other cases, the aggregated value is IGP
	    set_origin(Origin.IGP);
	}

	// - - - - - aggregate the AS paths - - - - -

	// I tried to follow the algorithm given in Appendix 6.8 of
	// RFC1771, but I find it unbelievably lacking in detail and
	// clarity.  Oh well, here goes ...

	// set up arrays of the ASes for convenience
	Integer[] pa1as = new Integer[aspath().length()];
	Integer[] pa2as = new Integer[r.aspath().length()];
	byte [] pa1type = new byte[aspath().length()];
	byte [] pa2type = new byte[r.aspath().length()];

	int nas1 = 0;
	for (int i=0; i<aspath().segs.size(); i++) {
	    Segment seg = (Segment)aspath().segs.get(i);
	    for (int j=0; j<seg.size(); j++, nas1++) {
		pa1as[nas1]   = (Integer) seg.asnhs.get(j);
		pa1type[nas1] = seg.typ;
	    }
	}
	int nas2 = 0;
	for (int i=0; i<r.aspath().segs.size(); i++) {
	    Segment rseg = (Segment)r.aspath().segs.get(i);
	    for (int j=0; j<rseg.size(); j++, nas2++) {
		pa2as[nas2]   = (Integer) rseg.asnhs.get(j);
		pa2type[nas2] = rseg.typ;
	    }
	}

	Integer[] pa3as = new Integer[nas1+nas2];
	byte [] pa3type = new byte[nas1+nas2];

	int nas3 = 0;
	int j;
	for (int i=0; i<nas1; i++) {
	    // first, do a quick check to see if this AS appears at all in
	    // the other AS path
	    boolean appears = false;
	    for (int k=0; k<nas2; k++) {
		if (pa2as[k].equals(pa1as[i]) && pa2type[k] == pa1type[i]) {
		    appears = true;
		    break;
		}
	    }
	    if (appears) {
		// it's in both AS paths
		j = 0;
		while (j < nas2 &&
		       (pa2as[j] == null ||
			!pa2as[j].equals(pa1as[i]) ||
			pa2type[j] != pa1type[i])) {
		    // put any intervening ASes into an AS_SET
		    if (pa2as[j] != null) {
			pa3as[nas3]   = pa2as[j];
			pa3type[nas3] = Segment.SET;
			pa2as[j] = null; // mark it so it's not included again
			nas3++;
		    }
		    j++;
		}
		if (j < nas2 && pa2as[j].equals(pa1as[i])) {
		    // it's the "same AS" in the second AS path
		    pa3as[nas3] = pa1as[i];
		    // make it a sequence no matter what the type was before
		    // (dunno if this is the correct thing to do ...)
		    pa3type[nas3] = Segment.SEQ;
		    pa2as[j] = null; // mark it so it's not included again
		    nas3++;
		}
	    } else {
		// it's only in the first AS path
		pa3as[nas3]   = pa1as[i];
		pa3type[nas3] = pa1type[i];
		nas3++;
	    }
	}
	// put the remaining ASes (if any) from the second AS path into an AS_SET
	for (j=0; j<nas2; j++) {
	    if (pa2as[j] != null) {
		pa3as[nas3]   = pa2as[j];
		pa3type[nas3] = Segment.SEQ;
		nas3++;
	    }
	}
	// clean out any repeats
	for (int m=0; m<nas3-1; m++) {
	    for (int n=m+1; n<nas3; n++) {
		if (pa3as[m].equals(pa3as[n])) {
		    pa3as[m] = null;
		    break;
		}
	    }
	}

	// convert from array back to path segments
	pas[ASpath.TYPECODE] = new ASpath(new ArrayList());
	int cur_seg_type = -1;
	Segment cur_seg = null;
	for (int p=0; p<nas3; p++) {
	    if (pa3as[p] != null) {
		// ignore -1's (they were repeats)
		if (cur_seg_type == pa3type[p]) {
		    cur_seg.append_as(pa3as[p].intValue());
		} else {
		    // we'll have to start a new segment of the opposite type
		    if (cur_seg != null) {
			// add the previous segment to the AS path
			aspath().append_segment(cur_seg);
		    }
		    // now start a new segment
		    cur_seg = new Segment(pa3type[p], new ArrayList());
		    cur_seg.append_as(pa3as[p].intValue());
		    cur_seg_type = pa3type[p];
		}
	    }
	}
	if (cur_seg != null) {
	    // append the last segment
	    aspath().append_segment(cur_seg);
	}

	// - - - - - aggregate the next hops - - - - -

	//   The two routes have identical NEXT_HOP attributes, or else
	//   this routine would not have been called.  The aggregate
	//   maintains this same value for next hop.

	// - - - - - aggregate the MEDs - - - - -

	//   The two routes have identical MULTI_EXIT_DISC attributes, or
	//   else this routine would not have been called.  The aggregate
	//   maintains this same value for MULTI_EXIT_DISC.

	// - - - - - aggregate the local preference attributes - - - - -

	//   This attribute is only used for local (within the same AS)
	//   messages, so it can be set to null.
	remove_attrib(LocalPref.TYPECODE);

	// - - - - - aggregate the atomic aggregate attributes - - - - -
    
	// if either has ATOMIC_AGGREGATE, the aggregate must have ATOMIC_AGGREGATE
	if (!has_atomicagg() && r.has_atomicagg()) {
	    set_atomicagg();
	}

	// - - - - - aggregate the aggregator attributes - - - - -

	//   this is always ignored when aggregating routes
	remove_attrib(Aggregator.TYPECODE);
    }


    // ----- Route.toString -------------------------------------- //
    /**
     * NLRI + mandatory attributes (AS_PATH, NEXT_HOP and ORIGIN)
     *      + communities
     *      + extended communities
     */
    public String toString()
    {
	String s= nlri.toString()+" ";

	s+= "["+aspath().toString()+"]";
	s+= "["+nexthop().toString()+"]";
	s+= "["+origin()+"]";
	s+= "<"+tbid()+">";
	if (to_string_comm && has_comm())
	    s+= "["+comm()+"]";
	if (to_string_extcomm && has_extcomm())
	    s+= "["+extcomm()+"]";

	return s;
    }
    /**
     * Return size (in bytes) of structure
     * @return
     */
    public int byteSize(){
    	// nlri size + 1 byte (nº de attributes) + size of all atrubutes (Variable size)
    	int size = nlri.byteSize();
    	size++; // +1 because num of atributes
    	for (int i = 0; i < pas.length;i++)
    		if (pas[i] != null)
    			size += pas[i].bytecount();
    	return size+1;
    }
    /**
     * Copy Route structure into Bytes array
     * @return array
     */
	public byte[] toBytes() {
		// nlri (IPaddres 5 bytes in this versioin)| nº of attribbutes (1 bytes) | attributes(variable size) 
		byte [] bytes = new byte[byteSize()];
		int pos = 0;
		
		bytes = BytesUtils.arrayCopy(nlri.bytes(), bytes, 0, pos);
		
		pos += nlri.byteSize();
		int pos2 = pos;
		// bytes[pos2] = nº de attribbs
		bytes[pos2] = 0;
		pos++;
    	for (int i = 0; i < pas.length;i++)
    		if (pas[i] != null){
    			bytes = BytesUtils.arrayCopy(pas[i].toBytes(), bytes, 0, pos);
    			bytes[pos2]++;
    			pos += pas[i].bytecount();
    		}

		return bytes;
	}
	/**
	 * Build a Route structure from a array of bytes
	 * @param bytes
	 * @return size of structure
	 */
	public int fromBytes(byte[] bytes){
		int pos = 0;
		nlri = new IPaddress(bytes);
		pos = nlri.byteSize();
		int nAtrib = bytes[pos++];
		for (int i = 0; i < nAtrib;i++){
			Attribute at = Attribute.buildNewAttribute(BytesUtils.arrayCopy(bytes, null, pos, 0));
			pas[at.type_code] = at;
			pos += pas[at.type_code].bytecount();

			
		}
		return pos;
	}

} // end of class Route
